# OpenManus é¡¹ç›®å®Œæ•´å­¦ä¹ æŒ‡å—

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æŠ€æœ¯æ ˆåˆ†æ](#æŠ€æœ¯æ ˆåˆ†æ)
3. [Python è¯­æ³•è¦ç‚¹](#pythonè¯­æ³•è¦ç‚¹)
4. [é¡¹ç›®æ¶æ„è¯¦è§£](#é¡¹ç›®æ¶æ„è¯¦è§£)
5. [æ ¸å¿ƒæ¨¡å—æ·±åº¦è§£æ](#æ ¸å¿ƒæ¨¡å—æ·±åº¦è§£æ)
6. [å®æˆ˜å¤åˆ»æ­¥éª¤](#å®æˆ˜å¤åˆ»æ­¥éª¤)
7. [å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)

---

## ğŸ¯ é¡¹ç›®æ¦‚è¿°

OpenManus æ˜¯ä¸€ä¸ªåŸºäºå¤§è¯­è¨€æ¨¡å‹çš„æ™ºèƒ½ä»£ç†æ¡†æ¶ï¼Œå…·å¤‡ä»¥ä¸‹æ ¸å¿ƒèƒ½åŠ›ï¼š

- **å¤šæ¨¡æ€ç†è§£**ï¼šæ”¯æŒæ–‡æœ¬å’Œå›¾åƒå¤„ç†
- **å·¥å…·è°ƒç”¨**ï¼šé›†æˆå¤šç§å¤–éƒ¨å·¥å…·ï¼ˆPython æ‰§è¡Œã€ç½‘é¡µæµè§ˆã€æ–‡ä»¶æ“ä½œç­‰ï¼‰
- **è§„åˆ’æ‰§è¡Œ**ï¼šæ™ºèƒ½ä»»åŠ¡åˆ†è§£å’Œæ‰§è¡Œ
- **å¼‚æ­¥å¤„ç†**ï¼šé«˜æ€§èƒ½å¹¶å‘æ‰§è¡Œ

### é¡¹ç›®ç»“æ„

```
OpenManus/
â”œâ”€â”€ app/                    # æ ¸å¿ƒåº”ç”¨ä»£ç 
â”‚   â”œâ”€â”€ agent/             # æ™ºèƒ½ä½“æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py        # åŸºç¡€æ™ºèƒ½ä½“æŠ½è±¡ç±»
â”‚   â”‚   â”œâ”€â”€ react.py       # ReActæ¨¡å¼æ™ºèƒ½ä½“
â”‚   â”‚   â”œâ”€â”€ toolcall.py    # å·¥å…·è°ƒç”¨æ™ºèƒ½ä½“
â”‚   â”‚   â”œâ”€â”€ planning.py    # è§„åˆ’æ™ºèƒ½ä½“
â”‚   â”‚   â”œâ”€â”€ swe.py         # è½¯ä»¶å·¥ç¨‹æ™ºèƒ½ä½“
â”‚   â”‚   â””â”€â”€ manus.py       # ä¸»è¦æ™ºèƒ½ä½“å®ç°
â”‚   â”œâ”€â”€ flow/              # æ‰§è¡Œæµç¨‹æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py        # åŸºç¡€æµç¨‹æŠ½è±¡ç±»
â”‚   â”‚   â”œâ”€â”€ planning.py    # è§„åˆ’æµç¨‹
â”‚   â”‚   â””â”€â”€ flow_factory.py # æµç¨‹å·¥å‚
â”‚   â”œâ”€â”€ tool/              # å·¥å…·æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py        # å·¥å…·åŸºç±»
â”‚   â”‚   â”œâ”€â”€ python_execute.py # Pythonæ‰§è¡Œå·¥å…·
â”‚   â”‚   â”œâ”€â”€ browser_use_tool.py # æµè§ˆå™¨å·¥å…·
â”‚   â”‚   â”œâ”€â”€ google_search.py # æœç´¢å·¥å…·
â”‚   â”‚   â”œâ”€â”€ file_saver.py  # æ–‡ä»¶æ“ä½œå·¥å…·
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ prompt/            # æç¤ºè¯æ¨¡å—
â”‚   â”œâ”€â”€ config.py          # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ llm.py            # LLMå®¢æˆ·ç«¯å°è£…
â”‚   â”œâ”€â”€ schema.py         # æ•°æ®æ¨¡å‹å®šä¹‰
â”‚   â”œâ”€â”€ logger.py         # æ—¥å¿—ç³»ç»Ÿ
â”‚   â””â”€â”€ exceptions.py     # å¼‚å¸¸å®šä¹‰
â”œâ”€â”€ config/               # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ config.toml       # ä¸»é…ç½®æ–‡ä»¶
â”‚   â””â”€â”€ config.example.toml # é…ç½®ç¤ºä¾‹
â”œâ”€â”€ main.py              # ä¸»å…¥å£æ–‡ä»¶
â”œâ”€â”€ run_flow.py          # æµç¨‹æ‰§è¡Œå…¥å£
â””â”€â”€ requirements.txt     # ä¾èµ–åˆ—è¡¨
```

---

## ğŸ› ï¸ æŠ€æœ¯æ ˆåˆ†æ

### æ ¸å¿ƒä¾èµ–åº“è¯¦è§£

#### 1. **Pydantic (2.10.4)** - æ•°æ®éªŒè¯å’Œè®¾ç½®ç®¡ç†

```python
# ç”¨é€”ï¼šæ•°æ®æ¨¡å‹å®šä¹‰ã€ç±»å‹éªŒè¯ã€é…ç½®ç®¡ç†
from pydantic import BaseModel, Field, model_validator

class Message(BaseModel):
    role: Literal["system", "user", "assistant", "tool"]
    content: Optional[str] = Field(default=None)
    tool_calls: Optional[List[ToolCall]] = Field(default=None)
```

**å…³é”®ç‰¹æ€§ï¼š**

- è‡ªåŠ¨ç±»å‹éªŒè¯
- JSON åºåˆ—åŒ–/ååºåˆ—åŒ–
- å­—æ®µéªŒè¯å™¨
- é…ç½®ç±»æ”¯æŒ

#### 2. **OpenAI (1.58.1)** - LLM API å®¢æˆ·ç«¯

```python
# ç”¨é€”ï¼šä¸å¤§è¯­è¨€æ¨¡å‹APIé€šä¿¡
from openai import AsyncOpenAI, APIError, AuthenticationError

client = AsyncOpenAI(
    api_key="your-api-key",
    base_url="https://api.openai.com/v1"
)
```

**å…³é”®ç‰¹æ€§ï¼š**

- å¼‚æ­¥ API è°ƒç”¨
- æµå¼å“åº”æ”¯æŒ
- å·¥å…·è°ƒç”¨åŠŸèƒ½
- é”™è¯¯å¤„ç†æœºåˆ¶

#### 3. **Tenacity (9.0.0)** - é‡è¯•æœºåˆ¶

```python
# ç”¨é€”ï¼šAPIè°ƒç”¨é‡è¯•ã€é”™è¯¯æ¢å¤
from tenacity import retry, stop_after_attempt, wait_random_exponential

@retry(
    wait=wait_random_exponential(min=1, max=60),
    stop=stop_after_attempt(6),
)
async def api_call():
    # å¯èƒ½å¤±è´¥çš„APIè°ƒç”¨
    pass
```

#### 4. **Loguru (0.7.3)** - æ—¥å¿—ç³»ç»Ÿ

```python
# ç”¨é€”ï¼šç»“æ„åŒ–æ—¥å¿—è®°å½•
from loguru import logger

logger.info("Processing request...")
logger.error("API call failed: {error}", error=str(e))
```

#### 5. **Browser-use (0.1.40)** - æµè§ˆå™¨è‡ªåŠ¨åŒ–

```python
# ç”¨é€”ï¼šç½‘é¡µè‡ªåŠ¨åŒ–æ“ä½œ
from browser_use import BrowserUseBrowser

browser = BrowserUseBrowser()
await browser.navigate("https://example.com")
```

#### 6. **å…¶ä»–é‡è¦ä¾èµ–**

- **aiofiles**: å¼‚æ­¥æ–‡ä»¶æ“ä½œ
- **googlesearch-python**: Google æœç´¢ API
- **pillow**: å›¾åƒå¤„ç†
- **colorama**: ç»ˆç«¯é¢œè‰²è¾“å‡º
- **pyyaml**: YAML é…ç½®æ–‡ä»¶æ”¯æŒ

---

## ğŸ Python è¯­æ³•è¦ç‚¹

### 1. å¼‚æ­¥ç¼–ç¨‹ (Async/Await)

#### åŸºç¡€æ¦‚å¿µ

```python
import asyncio

# å¼‚æ­¥å‡½æ•°å®šä¹‰
async def fetch_data():
    await asyncio.sleep(1)  # æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    return "data"

# å¼‚æ­¥å‡½æ•°è°ƒç”¨
async def main():
    result = await fetch_data()  # ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆ
    print(result)

# è¿è¡Œå¼‚æ­¥ç¨‹åº
asyncio.run(main())
```

#### å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨

```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def state_context(self, new_state):
    """å®‰å…¨çš„çŠ¶æ€è½¬æ¢ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    previous_state = self.state
    self.state = new_state
    try:
        yield  # åœ¨è¿™é‡Œæ‰§è¡Œä¸Šä¸‹æ–‡å†…çš„ä»£ç 
    except Exception as e:
        self.state = AgentState.ERROR
        raise e
    finally:
        self.state = previous_state  # æ¢å¤åŸçŠ¶æ€
```

#### å¹¶å‘æ‰§è¡Œ

```python
import asyncio

async def concurrent_tasks():
    # å¹¶å‘æ‰§è¡Œå¤šä¸ªä»»åŠ¡
    tasks = [
        fetch_data("url1"),
        fetch_data("url2"),
        fetch_data("url3")
    ]
    results = await asyncio.gather(*tasks)
    return results
```

### 2. æŠ½è±¡åŸºç±» (ABC)

#### å®šä¹‰æŠ½è±¡åŸºç±»

```python
from abc import ABC, abstractmethod

class BaseAgent(ABC):
    """æŠ½è±¡åŸºç±»å®šä¹‰æ¥å£è§„èŒƒ"""

    @abstractmethod
    async def step(self) -> str:
        """å­ç±»å¿…é¡»å®ç°çš„æŠ½è±¡æ–¹æ³•"""
        pass

    def common_method(self):
        """æ‰€æœ‰å­ç±»å…±äº«çš„å…·ä½“æ–¹æ³•"""
        return "common functionality"
```

#### å®ç°æŠ½è±¡åŸºç±»

```python
class ConcreteAgent(BaseAgent):
    """å…·ä½“å®ç°ç±»"""

    async def step(self) -> str:
        """å®ç°æŠ½è±¡æ–¹æ³•"""
        return "executed step"
```

### 3. ç±»å‹æ³¨è§£ (Type Hints)

#### åŸºç¡€ç±»å‹æ³¨è§£

```python
from typing import List, Dict, Optional, Union, Literal

def process_data(
    items: List[str],                    # å­—ç¬¦ä¸²åˆ—è¡¨
    config: Dict[str, int],              # å­—ç¬¦ä¸²åˆ°æ•´æ•°çš„æ˜ å°„
    timeout: Optional[float] = None,     # å¯é€‰çš„æµ®ç‚¹æ•°
    mode: Literal["fast", "slow"] = "fast"  # å­—é¢é‡ç±»å‹
) -> Union[str, None]:                   # è¿”å›å­—ç¬¦ä¸²æˆ–None
    pass
```

#### æ³›å‹å’Œåè®®

```python
from typing import TypeVar, Generic, Protocol

T = TypeVar('T')

class Container(Generic[T]):
    """æ³›å‹å®¹å™¨ç±»"""
    def __init__(self, item: T):
        self.item = item

    def get_item(self) -> T:
        return self.item

# åè®®å®šä¹‰
class Executable(Protocol):
    async def execute(self, **kwargs) -> str:
        ...
```

### 4. è£…é¥°å™¨æ¨¡å¼

#### å‡½æ•°è£…é¥°å™¨

```python
from functools import wraps

def log_calls(func):
    """è®°å½•å‡½æ•°è°ƒç”¨çš„è£…é¥°å™¨"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        logger.info(f"Calling {func.__name__}")
        try:
            result = await func(*args, **kwargs)
            logger.info(f"{func.__name__} completed successfully")
            return result
        except Exception as e:
            logger.error(f"{func.__name__} failed: {e}")
            raise
    return wrapper

# ä½¿ç”¨è£…é¥°å™¨
@log_calls
async def api_call():
    pass
```

#### ç±»è£…é¥°å™¨

```python
def singleton(cls):
    """å•ä¾‹æ¨¡å¼è£…é¥°å™¨"""
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Config:
    pass
```

### 5. ä¸Šä¸‹æ–‡ç®¡ç†å™¨

#### åŸºç¡€ä¸Šä¸‹æ–‡ç®¡ç†å™¨

```python
class DatabaseConnection:
    def __enter__(self):
        print("Opening connection")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing connection")
        if exc_type:
            print(f"Exception occurred: {exc_val}")
        return False  # ä¸æŠ‘åˆ¶å¼‚å¸¸

# ä½¿ç”¨
with DatabaseConnection() as conn:
    # ä½¿ç”¨è¿æ¥
    pass
```

#### å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨

```python
class AsyncDatabaseConnection:
    async def __aenter__(self):
        print("Opening async connection")
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("Closing async connection")
        return False

# ä½¿ç”¨
async with AsyncDatabaseConnection() as conn:
    # ä½¿ç”¨å¼‚æ­¥è¿æ¥
    pass
```

---

## ğŸ—ï¸ é¡¹ç›®æ¶æ„è¯¦è§£

### 1. åˆ†å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ç”¨æˆ·æ¥å£å±‚                â”‚
â”‚        (main.py, run_flow.py)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           æµç¨‹æ§åˆ¶å±‚                â”‚
â”‚         (Flow Classes)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           æ™ºèƒ½ä½“å±‚                  â”‚
â”‚        (Agent Classes)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           å·¥å…·æ‰§è¡Œå±‚                â”‚
â”‚         (Tool Classes)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           åŸºç¡€æœåŠ¡å±‚                â”‚
â”‚    (LLM, Config, Logger, Schema)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. è®¾è®¡æ¨¡å¼åº”ç”¨

#### å•ä¾‹æ¨¡å¼ - é…ç½®ç®¡ç†

```python
class Config:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
```

**ä¸ºä»€ä¹ˆä½¿ç”¨å•ä¾‹æ¨¡å¼ï¼Ÿ**

- ç¡®ä¿å…¨å±€åªæœ‰ä¸€ä¸ªé…ç½®å®ä¾‹
- é¿å…é‡å¤åŠ è½½é…ç½®æ–‡ä»¶
- çº¿ç¨‹å®‰å…¨çš„å®ç°

#### å·¥å‚æ¨¡å¼ - Flow åˆ›å»º

```python
class FlowFactory:
    @staticmethod
    def create_flow(flow_type: FlowType, agents, **kwargs) -> BaseFlow:
        flow_map = {
            FlowType.PLANNING: PlanningFlow,
        }

        flow_class = flow_map.get(flow_type)
        if not flow_class:
            raise ValueError(f"Unknown flow type: {flow_type}")

        return flow_class(agents, **kwargs)
```

**ä¸ºä»€ä¹ˆä½¿ç”¨å·¥å‚æ¨¡å¼ï¼Ÿ**

- è§£è€¦å¯¹è±¡åˆ›å»ºå’Œä½¿ç”¨
- ä¾¿äºæ‰©å±•æ–°çš„ Flow ç±»å‹
- ç»Ÿä¸€çš„åˆ›å»ºæ¥å£

#### ç­–ç•¥æ¨¡å¼ - Agent å®ç°

```python
class BaseAgent(ABC):
    @abstractmethod
    async def step(self) -> str:
        """ä¸åŒAgentæœ‰ä¸åŒçš„æ‰§è¡Œç­–ç•¥"""
        pass

class ReActAgent(BaseAgent):
    async def step(self) -> str:
        should_act = await self.think()
        if should_act:
            return await self.act()
        return "No action needed"

class ToolCallAgent(ReActAgent):
    async def step(self) -> str:
        # å·¥å…·è°ƒç”¨ç­–ç•¥çš„å…·ä½“å®ç°
        pass
```

#### è§‚å¯Ÿè€…æ¨¡å¼ - å†…å­˜ç®¡ç†

```python
class Memory(BaseModel):
    messages: List[Message] = Field(default_factory=list)

    def add_message(self, message: Message) -> None:
        """æ·»åŠ æ¶ˆæ¯æ—¶è‡ªåŠ¨è§¦å‘ç›¸å…³å¤„ç†"""
        self.messages.append(message)
        # å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è§‚å¯Ÿè€…é€šçŸ¥é€»è¾‘
        self._notify_observers(message)

    def _notify_observers(self, message: Message):
        # é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
        pass
```

### 3. ä¾èµ–æ³¨å…¥

```python
class BaseAgent(BaseModel):
    # é€šè¿‡Fieldæ³¨å…¥ä¾èµ–
    llm: LLM = Field(default_factory=LLM)
    memory: Memory = Field(default_factory=Memory)

    @model_validator(mode="after")
    def initialize_agent(self) -> "BaseAgent":
        """åˆå§‹åŒ–æ—¶æ³¨å…¥ä¾èµ–"""
        if self.llm is None:
            self.llm = LLM(config_name=self.name.lower())
        return self
```

---

## ğŸ” æ ¸å¿ƒæ¨¡å—æ·±åº¦è§£æ

### 1. é…ç½®ç®¡ç†æ¨¡å— (config.py)

#### é…ç½®åŠ è½½æœºåˆ¶

```python
class Config:
    def _load_config(self) -> dict:
        """é…ç½®æ–‡ä»¶åŠ è½½ä¼˜å…ˆçº§"""
        config_path = self._get_config_path()
        with config_path.open("rb") as f:
            return tomllib.load(f)  # Python 3.11+ å†…ç½®TOMLæ”¯æŒ

    @staticmethod
    def _get_config_path() -> Path:
        """é…ç½®æ–‡ä»¶æŸ¥æ‰¾é¡ºåº"""
        root = PROJECT_ROOT
        # 1. ä¼˜å…ˆä½¿ç”¨ config.toml
        config_path = root / "config" / "config.toml"
        if config_path.exists():
            return config_path
        # 2. å›é€€åˆ°ç¤ºä¾‹é…ç½®
        example_path = root / "config" / "config.example.toml"
        if example_path.exists():
            return example_path
        # 3. éƒ½æ²¡æœ‰åˆ™æŠ›å‡ºå¼‚å¸¸
        raise FileNotFoundError("No configuration file found")
```

#### é…ç½®ç»“æ„è®¾è®¡

```python
class LLMSettings(BaseModel):
    """LLMé…ç½®æ¨¡å‹"""
    model: str = Field(..., description="Model name")
    base_url: str = Field(..., description="API base URL")
    api_key: str = Field(..., description="API key")
    max_tokens: int = Field(4096, description="Maximum tokens")
    temperature: float = Field(1.0, description="Sampling temperature")

class AppConfig(BaseModel):
    """åº”ç”¨é…ç½®æ¨¡å‹"""
    llm: Dict[str, LLMSettings]  # æ”¯æŒå¤šä¸ªLLMé…ç½®
```

#### é…ç½®ç»§æ‰¿æœºåˆ¶

```python
def _load_initial_config(self):
    """é…ç½®ç»§æ‰¿å’Œè¦†ç›–æœºåˆ¶"""
    raw_config = self._load_config()
    base_llm = raw_config.get("llm", {})

    # æå–åŸºç¡€é…ç½®
    default_settings = {
        "model": base_llm.get("model"),
        "base_url": base_llm.get("base_url"),
        "api_key": base_llm.get("api_key"),
        "max_tokens": base_llm.get("max_tokens", 4096),
        "temperature": base_llm.get("temperature", 1.0),
    }

    # å¤„ç†ç‰¹æ®Šé…ç½®ï¼ˆå¦‚visionï¼‰
    llm_overrides = {
        k: v for k, v in raw_config.get("llm", {}).items()
        if isinstance(v, dict)
    }

    # åˆå¹¶é…ç½®ï¼šç‰¹æ®Šé…ç½®ç»§æ‰¿åŸºç¡€é…ç½®
    config_dict = {
        "llm": {
            "default": default_settings,
            **{
                name: {**default_settings, **override_config}
                for name, override_config in llm_overrides.items()
            },
        }
    }
```

### 2. LLM å®¢æˆ·ç«¯æ¨¡å— (llm.py)

#### å•ä¾‹æ¨¡å¼å®ç°

```python
class LLM:
    _instances: Dict[str, "LLM"] = {}  # ç±»å˜é‡å­˜å‚¨å®ä¾‹

    def __new__(cls, config_name: str = "default", llm_config: Optional[LLMSettings] = None):
        """å•ä¾‹æ¨¡å¼ï¼šæ¯ä¸ªé…ç½®åç§°å¯¹åº”ä¸€ä¸ªå®ä¾‹"""
        if config_name not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(config_name, llm_config)
            cls._instances[config_name] = instance
        return cls._instances[config_name]
```

#### é‡è¯•æœºåˆ¶å®ç°

```python
@retry(
    wait=wait_random_exponential(min=1, max=60),  # æŒ‡æ•°é€€é¿
    stop=stop_after_attempt(6),                   # æœ€å¤šé‡è¯•6æ¬¡
)
async def ask_tool(self, messages, **kwargs):
    """å¸¦é‡è¯•çš„APIè°ƒç”¨"""
    try:
        response = await self.client.chat.completions.create(
            model=self.model,
            messages=messages,
            **kwargs
        )
        return response.choices[0].message
    except OpenAIError as e:
        logger.error(f"API call failed: {e}")
        raise  # é‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Œè§¦å‘é‡è¯•
```

#### æ¶ˆæ¯æ ¼å¼åŒ–

```python
@staticmethod
def format_messages(messages: List[Union[dict, Message]]) -> List[dict]:
    """ç»Ÿä¸€æ¶ˆæ¯æ ¼å¼"""
    formatted_messages = []

    for message in messages:
        if isinstance(message, dict):
            # éªŒè¯å­—å…¸æ ¼å¼
            if "role" not in message:
                raise ValueError("Message dict must contain 'role' field")
            formatted_messages.append(message)
        elif isinstance(message, Message):
            # è½¬æ¢Messageå¯¹è±¡
            formatted_messages.append(message.to_dict())
        else:
            raise TypeError(f"Unsupported message type: {type(message)}")

    return formatted_messages
```

### 3. æ•°æ®æ¨¡å‹æ¨¡å— (schema.py)

#### æ¶ˆæ¯ç³»ç»Ÿè®¾è®¡

```python
class Message(BaseModel):
    """æ¶ˆæ¯æ¨¡å‹æ”¯æŒå¤šç§è§’è‰²å’Œå†…å®¹ç±»å‹"""
    role: Literal["system", "user", "assistant", "tool"]
    content: Optional[str] = Field(default=None)
    tool_calls: Optional[List[ToolCall]] = Field(default=None)
    name: Optional[str] = Field(default=None)
    tool_call_id: Optional[str] = Field(default=None)

    def __add__(self, other) -> List["Message"]:
        """æ”¯æŒæ¶ˆæ¯é“¾å¼æ“ä½œ"""
        if isinstance(other, list):
            return [self] + other
        elif isinstance(other, Message):
            return [self, other]
        else:
            raise TypeError("Unsupported operand type")
```

#### å·¥å‚æ–¹æ³•æ¨¡å¼

```python
class Message(BaseModel):
    @classmethod
    def user_message(cls, content: str) -> "Message":
        """åˆ›å»ºç”¨æˆ·æ¶ˆæ¯"""
        return cls(role="user", content=content)

    @classmethod
    def system_message(cls, content: str) -> "Message":
        """åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯"""
        return cls(role="system", content=content)

    @classmethod
    def tool_message(cls, content: str, name: str, tool_call_id: str) -> "Message":
        """åˆ›å»ºå·¥å…·æ¶ˆæ¯"""
        return cls(role="tool", content=content, name=name, tool_call_id=tool_call_id)
```

#### å†…å­˜ç®¡ç†

```python
class Memory(BaseModel):
    """æ™ºèƒ½ä½“è®°å¿†ç³»ç»Ÿ"""
    messages: List[Message] = Field(default_factory=list)
    max_messages: int = Field(default=100)

    def add_message(self, message: Message) -> None:
        """æ·»åŠ æ¶ˆæ¯å¹¶ç®¡ç†å†…å­˜å¤§å°"""
        self.messages.append(message)
        # è‡ªåŠ¨æ¸…ç†æ—§æ¶ˆæ¯
        if len(self.messages) > self.max_messages:
            self.messages = self.messages[-self.max_messages:]

    def get_recent_messages(self, n: int) -> List[Message]:
        """è·å–æœ€è¿‘çš„næ¡æ¶ˆæ¯"""
        return self.messages[-n:]
```

### 4. æ™ºèƒ½ä½“åŸºç±» (agent/base.py)

#### çŠ¶æ€ç®¡ç†

```python
class AgentState(str, Enum):
    """æ™ºèƒ½ä½“çŠ¶æ€æšä¸¾"""
    IDLE = "IDLE"
    RUNNING = "RUNNING"
    FINISHED = "FINISHED"
    ERROR = "ERROR"

class BaseAgent(BaseModel, ABC):
    state: AgentState = Field(default=AgentState.IDLE)

    @asynccontextmanager
    async def state_context(self, new_state: AgentState):
        """å®‰å…¨çš„çŠ¶æ€è½¬æ¢"""
        previous_state = self.state
        self.state = new_state
        try:
            yield
        except Exception as e:
            self.state = AgentState.ERROR
            raise e
        finally:
            self.state = previous_state
```

#### æ‰§è¡Œå¾ªç¯

```python
async def run(self, request: Optional[str] = None) -> str:
    """æ™ºèƒ½ä½“ä¸»æ‰§è¡Œå¾ªç¯"""
    if self.state != AgentState.IDLE:
        raise RuntimeError(f"Cannot run agent from state: {self.state}")

    if request:
        self.update_memory("user", request)

    results: List[str] = []
    async with self.state_context(AgentState.RUNNING):
        while (self.current_step < self.max_steps and
               self.state != AgentState.FINISHED):

            self.current_step += 1
            logger.info(f"Executing step {self.current_step}/{self.max_steps}")

            # æ‰§è¡Œå•æ­¥
            step_result = await self.step()

            # æ£€æŸ¥æ˜¯å¦é™·å…¥å¾ªç¯
            if self.is_stuck():
                self.handle_stuck_state()

            results.append(f"Step {self.current_step}: {step_result}")

    return "\n".join(results)
```

#### é˜²å¾ªç¯æœºåˆ¶

```python
def is_stuck(self) -> bool:
    """æ£€æµ‹æ˜¯å¦é™·å…¥é‡å¤å¾ªç¯"""
    if len(self.memory.messages) < 2:
        return False

    last_message = self.memory.messages[-1]
    if not last_message.content:
        return False

    # ç»Ÿè®¡ç›¸åŒå†…å®¹å‡ºç°æ¬¡æ•°
    duplicate_count = sum(
        1 for msg in reversed(self.memory.messages[:-1])
        if (msg.role == "assistant" and
            msg.content == last_message.content)
    )

    return duplicate_count >= self.duplicate_threshold

def handle_stuck_state(self):
    """å¤„ç†å¾ªç¯çŠ¶æ€"""
    stuck_prompt = "Detected duplicate responses. Try new strategies."
    self.next_step_prompt = f"{stuck_prompt}\n{self.next_step_prompt}"
    logger.warning("Agent stuck state detected")
```

### 5. å·¥å…·ç³»ç»Ÿ (tool/)

#### å·¥å…·åŸºç±»è®¾è®¡

```python
class BaseTool(ABC, BaseModel):
    """å·¥å…·åŸºç±»å®šä¹‰æ ‡å‡†æ¥å£"""
    name: str
    description: str
    parameters: Optional[dict] = None

    async def __call__(self, **kwargs) -> Any:
        """ä½¿å·¥å…·å¯¹è±¡å¯è°ƒç”¨"""
        return await self.execute(**kwargs)

    @abstractmethod
    async def execute(self, **kwargs) -> Any:
        """å­ç±»å¿…é¡»å®ç°çš„æ‰§è¡Œæ–¹æ³•"""
        pass

    def to_param(self) -> Dict:
        """è½¬æ¢ä¸ºLLMå‡½æ•°è°ƒç”¨æ ¼å¼"""
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters,
            },
        }
```

#### å·¥å…·é›†åˆç®¡ç†

```python
class ToolCollection:
    """å·¥å…·é›†åˆç®¡ç†å™¨"""

    def __init__(self, *tools: BaseTool):
        self.tools = tools
        self.tool_map = {tool.name: tool for tool in tools}

    async def execute(self, *, name: str, tool_input: Dict[str, Any] = None) -> ToolResult:
        """æ‰§è¡ŒæŒ‡å®šå·¥å…·"""
        tool = self.tool_map.get(name)
        if not tool:
            return ToolFailure(error=f"Tool {name} is invalid")

        try:
            result = await tool(**tool_input or {})
            return result
        except ToolError as e:
            return ToolFailure(error=e.message)
```

#### Python æ‰§è¡Œå·¥å…·å®ç°

```python
class PythonExecute(BaseTool):
    """Pythonä»£ç æ‰§è¡Œå·¥å…·"""
    name: str = "python_execute"
    description: str = "Executes Python code with timeout and safety restrictions."

    async def execute(self, code: str, timeout: int = 5) -> Dict:
        """å®‰å…¨æ‰§è¡ŒPythonä»£ç """
        result = {"observation": ""}

        def run_code():
            try:
                # åˆ›å»ºå®‰å…¨çš„æ‰§è¡Œç¯å¢ƒ
                safe_globals = {"__builtins__": dict(__builtins__)}

                # é‡å®šå‘è¾“å‡º
                import sys
                from io import StringIO
                output_buffer = StringIO()
                sys.stdout = output_buffer

                # æ‰§è¡Œä»£ç 
                exec(code, safe_globals, {})

                # æ¢å¤è¾“å‡º
                sys.stdout = sys.__stdout__
                result["observation"] = output_buffer.getvalue()

            except Exception as e:
                result["observation"] = str(e)
                result["success"] = False

        # ä½¿ç”¨çº¿ç¨‹æ‰§è¡Œï¼Œæ”¯æŒè¶…æ—¶
        thread = threading.Thread(target=run_code)
        thread.start()
        thread.join(timeout)

        if thread.is_alive():
            return {
                "observation": f"Execution timeout after {timeout} seconds",
                "success": False,
            }

        return result
```

### 6. å·¥å…·è°ƒç”¨æ™ºèƒ½ä½“ (agent/toolcall.py)

#### ReAct æ¨¡å¼å®ç°

```python
class ToolCallAgent(ReActAgent):
    """å·¥å…·è°ƒç”¨æ™ºèƒ½ä½“å®ç°ReActæ¨¡å¼"""

    async def think(self) -> bool:
        """æ€è€ƒé˜¶æ®µï¼šå†³å®šä½¿ç”¨å“ªäº›å·¥å…·"""
        # æ·»åŠ æç¤ºæ¶ˆæ¯
        if self.next_step_prompt:
            user_msg = Message.user_message(self.next_step_prompt)
            self.messages += [user_msg]

        # è·å–LLMå“åº”ï¼ˆåŒ…å«å·¥å…·è°ƒç”¨ï¼‰
        response = await self.llm.ask_tool(
            messages=self.messages,
            system_msgs=[Message.system_message(self.system_prompt)]
            if self.system_prompt else None,
            tools=self.available_tools.to_params(),
            tool_choice=self.tool_choices,
        )

        # ä¿å­˜å·¥å…·è°ƒç”¨ä¿¡æ¯
        self.tool_calls = response.tool_calls

        # è®°å½•åˆ°å†…å­˜
        assistant_msg = (
            Message.from_tool_calls(
                content=response.content,
                tool_calls=self.tool_calls
            ) if self.tool_calls
            else Message.assistant_message(response.content)
        )
        self.memory.add_message(assistant_msg)

        return bool(self.tool_calls)

    async def act(self) -> str:
        """è¡ŒåŠ¨é˜¶æ®µï¼šæ‰§è¡Œå·¥å…·è°ƒç”¨"""
        if not self.tool_calls:
            return "No tools to execute"

        results = []
        for command in self.tool_calls:
            # æ‰§è¡Œå•ä¸ªå·¥å…·
            result = await self.execute_tool(command)

            # è®°å½•å·¥å…·æ‰§è¡Œç»“æœ
            tool_msg = Message.tool_message(
                content=result,
                tool_call_id=command.id,
                name=command.function.name
            )
            self.memory.add_message(tool_msg)
            results.append(result)

        return "\n\n".join(results)
```

#### å·¥å…·æ‰§è¡Œä¸é”™è¯¯å¤„ç†

```python
async def execute_tool(self, command: ToolCall) -> str:
    """æ‰§è¡Œå•ä¸ªå·¥å…·è°ƒç”¨"""
    if not command or not command.function:
        return "Error: Invalid command format"

    name = command.function.name
    if name not in self.available_tools.tool_map:
        return f"Error: Unknown tool '{name}'"

    try:
        # è§£æå‚æ•°
        args = json.loads(command.function.arguments or "{}")

        # æ‰§è¡Œå·¥å…·
        result = await self.available_tools.execute(
            name=name,
            tool_input=args
        )

        # å¤„ç†ç‰¹æ®Šå·¥å…·ï¼ˆå¦‚ç»ˆæ­¢å·¥å…·ï¼‰
        await self._handle_special_tool(name=name, result=result)

        return f"Tool '{name}' executed: {str(result)}"

    except json.JSONDecodeError:
        return f"Error: Invalid JSON arguments for {name}"
    except Exception as e:
        return f"Error: Tool '{name}' failed: {str(e)}"
```

---

## ğŸš€ å®æˆ˜å¤åˆ»æ­¥éª¤

### ç¬¬ä¸€é˜¶æ®µï¼šç¯å¢ƒæ­å»ºå’ŒåŸºç¡€æ¡†æ¶

#### æ­¥éª¤ 1ï¼šåˆ›å»ºé¡¹ç›®ç»“æ„

```bash
# åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir MyOpenManus
cd MyOpenManus

# åˆ›å»ºåŸºç¡€ç›®å½•ç»“æ„
mkdir -p app/{agent,flow,tool,prompt}
mkdir -p config
mkdir -p logs

# åˆ›å»ºåˆå§‹æ–‡ä»¶
touch app/__init__.py
touch app/agent/__init__.py
touch app/flow/__init__.py
touch app/tool/__init__.py
touch app/prompt/__init__.py
touch main.py
touch requirements.txt
```

#### æ­¥éª¤ 2ï¼šå®‰è£…ä¾èµ–

```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# å®‰è£…æ ¸å¿ƒä¾èµ–
pip install pydantic==2.10.4
pip install openai==1.58.1
pip install tenacity==9.0.0
pip install loguru==0.7.3
pip install aiofiles==24.1.0
```

#### æ­¥éª¤ 3ï¼šå®ç°é…ç½®ç³»ç»Ÿ

```python
# app/config.py
import threading
import tomllib
from pathlib import Path
from typing import Dict
from pydantic import BaseModel, Field

def get_project_root() -> Path:
    return Path(__file__).resolve().parent.parent

PROJECT_ROOT = get_project_root()

class LLMSettings(BaseModel):
    model: str = Field(..., description="Model name")
    base_url: str = Field(..., description="API base URL")
    api_key: str = Field(..., description="API key")
    max_tokens: int = Field(4096, description="Maximum tokens")
    temperature: float = Field(1.0, description="Sampling temperature")

class AppConfig(BaseModel):
    llm: Dict[str, LLMSettings]

class Config:
    _instance = None
    _lock = threading.Lock()
    _initialized = False

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if not self._initialized:
            with self._lock:
                if not self._initialized:
                    self._config = None
                    self._load_initial_config()
                    self._initialized = True

    def _load_config(self) -> dict:
        config_path = PROJECT_ROOT / "config" / "config.toml"
        if not config_path.exists():
            raise FileNotFoundError("Configuration file not found")

        with config_path.open("rb") as f:
            return tomllib.load(f)

    def _load_initial_config(self):
        raw_config = self._load_config()
        base_llm = raw_config.get("llm", {})

        default_settings = {
            "model": base_llm.get("model"),
            "base_url": base_llm.get("base_url"),
            "api_key": base_llm.get("api_key"),
            "max_tokens": base_llm.get("max_tokens", 4096),
            "temperature": base_llm.get("temperature", 1.0),
        }

        config_dict = {"llm": {"default": default_settings}}
        self._config = AppConfig(**config_dict)

    @property
    def llm(self) -> Dict[str, LLMSettings]:
        return self._config.llm

config = Config()
```

#### æ­¥éª¤ 4ï¼šå®ç°æ—¥å¿—ç³»ç»Ÿ

```python
# app/logger.py
import sys
from datetime import datetime
from loguru import logger as _logger
from app.config import PROJECT_ROOT

def setup_logger(print_level="INFO", logfile_level="DEBUG"):
    current_date = datetime.now().strftime("%Y%m%d")

    _logger.remove()
    _logger.add(sys.stderr, level=print_level)
    _logger.add(PROJECT_ROOT / f"logs/{current_date}.log", level=logfile_level)
    return _logger

logger = setup_logger()
```

### ç¬¬äºŒé˜¶æ®µï¼šæ•°æ®æ¨¡å‹å’ŒåŸºç¡€ç±»

#### æ­¥éª¤ 5ï¼šå®ç°æ•°æ®æ¨¡å‹

```python
# app/schema.py
from enum import Enum
from typing import List, Literal, Optional
from pydantic import BaseModel, Field

class AgentState(str, Enum):
    IDLE = "IDLE"
    RUNNING = "RUNNING"
    FINISHED = "FINISHED"
    ERROR = "ERROR"

class ToolCall(BaseModel):
    id: str
    type: str = "function"
    function: dict

class Message(BaseModel):
    role: Literal["system", "user", "assistant", "tool"]
    content: Optional[str] = Field(default=None)
    tool_calls: Optional[List[ToolCall]] = Field(default=None)
    name: Optional[str] = Field(default=None)
    tool_call_id: Optional[str] = Field(default=None)

    @classmethod
    def user_message(cls, content: str) -> "Message":
        return cls(role="user", content=content)

    @classmethod
    def system_message(cls, content: str) -> "Message":
        return cls(role="system", content=content)

    @classmethod
    def assistant_message(cls, content: str) -> "Message":
        return cls(role="assistant", content=content)

    def to_dict(self) -> dict:
        result = {"role": self.role}
        if self.content is not None:
            result["content"] = self.content
        if self.tool_calls is not None:
            result["tool_calls"] = [tc.dict() for tc in self.tool_calls]
        return result

class Memory(BaseModel):
    messages: List[Message] = Field(default_factory=list)
    max_messages: int = Field(default=100)

    def add_message(self, message: Message) -> None:
        self.messages.append(message)
        if len(self.messages) > self.max_messages:
            self.messages = self.messages[-self.max_messages:]
```

#### æ­¥éª¤ 6ï¼šå®ç° LLM å®¢æˆ·ç«¯

```python
# app/llm.py
from typing import Dict, List, Optional, Union
from openai import AsyncOpenAI
from tenacity import retry, stop_after_attempt, wait_random_exponential
from app.config import LLMSettings, config
from app.logger import logger
from app.schema import Message

class LLM:
    _instances: Dict[str, "LLM"] = {}

    def __new__(cls, config_name: str = "default"):
        if config_name not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(config_name)
            cls._instances[config_name] = instance
        return cls._instances[config_name]

    def __init__(self, config_name: str = "default"):
        if not hasattr(self, "client"):
            llm_config = config.llm[config_name]
            self.model = llm_config.model
            self.max_tokens = llm_config.max_tokens
            self.temperature = llm_config.temperature
            self.client = AsyncOpenAI(
                api_key=llm_config.api_key,
                base_url=llm_config.base_url
            )

    @staticmethod
    def format_messages(messages: List[Union[dict, Message]]) -> List[dict]:
        formatted = []
        for msg in messages:
            if isinstance(msg, dict):
                formatted.append(msg)
            elif isinstance(msg, Message):
                formatted.append(msg.to_dict())
        return formatted

    @retry(
        wait=wait_random_exponential(min=1, max=60),
        stop=stop_after_attempt(3),
    )
    async def ask(self, messages: List[Union[dict, Message]], **kwargs) -> str:
        formatted_messages = self.format_messages(messages)

        response = await self.client.chat.completions.create(
            model=self.model,
            messages=formatted_messages,
            max_tokens=self.max_tokens,
            temperature=self.temperature,
            **kwargs
        )

        return response.choices[0].message.content

    @retry(
        wait=wait_random_exponential(min=1, max=60),
        stop=stop_after_attempt(3),
    )
    async def ask_tool(self, messages: List[Union[dict, Message]],
                      tools: Optional[List[dict]] = None, **kwargs):
        formatted_messages = self.format_messages(messages)

        response = await self.client.chat.completions.create(
            model=self.model,
            messages=formatted_messages,
            max_tokens=self.max_tokens,
            temperature=self.temperature,
            tools=tools,
            **kwargs
        )

        return response.choices[0].message
```

### ç¬¬ä¸‰é˜¶æ®µï¼šæ™ºèƒ½ä½“ç³»ç»Ÿ

#### æ­¥éª¤ 7ï¼šå®ç°åŸºç¡€æ™ºèƒ½ä½“

```python
# app/agent/base.py
from abc import ABC, abstractmethod
from contextlib import asynccontextmanager
from typing import Optional
from pydantic import BaseModel, Field
from app.llm import LLM
from app.logger import logger
from app.schema import AgentState, Memory, Message

class BaseAgent(BaseModel, ABC):
    name: str = Field(..., description="Agent name")
    description: Optional[str] = Field(None, description="Agent description")

    llm: LLM = Field(default_factory=LLM)
    memory: Memory = Field(default_factory=Memory)
    state: AgentState = Field(default=AgentState.IDLE)

    max_steps: int = Field(default=10)
    current_step: int = Field(default=0)

    class Config:
        arbitrary_types_allowed = True

    @asynccontextmanager
    async def state_context(self, new_state: AgentState):
        previous_state = self.state
        self.state = new_state
        try:
            yield
        except Exception as e:
            self.state = AgentState.ERROR
            raise e
        finally:
            self.state = previous_state

    async def run(self, request: Optional[str] = None) -> str:
        if self.state != AgentState.IDLE:
            raise RuntimeError(f"Cannot run agent from state: {self.state}")

        if request:
            self.memory.add_message(Message.user_message(request))

        results = []
        async with self.state_context(AgentState.RUNNING):
            while (self.current_step < self.max_steps and
                   self.state != AgentState.FINISHED):

                self.current_step += 1
                logger.info(f"Step {self.current_step}/{self.max_steps}")

                step_result = await self.step()
                results.append(f"Step {self.current_step}: {step_result}")

        return "\n".join(results)

    @abstractmethod
    async def step(self) -> str:
        pass
```

#### æ­¥éª¤ 8ï¼šå®ç° ReAct æ™ºèƒ½ä½“

```python
# app/agent/react.py
from abc import abstractmethod
from app.agent.base import BaseAgent

class ReActAgent(BaseAgent):
    @abstractmethod
    async def think(self) -> bool:
        """æ€è€ƒé˜¶æ®µï¼šåˆ†æå½“å‰çŠ¶æ€ï¼Œå†³å®šæ˜¯å¦éœ€è¦è¡ŒåŠ¨"""
        pass

    @abstractmethod
    async def act(self) -> str:
        """è¡ŒåŠ¨é˜¶æ®µï¼šæ‰§è¡Œå…·ä½“è¡ŒåŠ¨"""
        pass

    async def step(self) -> str:
        should_act = await self.think()
        if should_act:
            return await self.act()
        return "No action needed"
```

### ç¬¬å››é˜¶æ®µï¼šå·¥å…·ç³»ç»Ÿ

#### æ­¥éª¤ 9ï¼šå®ç°å·¥å…·åŸºç±»

```python
# app/tool/base.py
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
from pydantic import BaseModel

class BaseTool(ABC, BaseModel):
    name: str
    description: str
    parameters: Optional[dict] = None

    class Config:
        arbitrary_types_allowed = True

    async def __call__(self, **kwargs) -> Any:
        return await self.execute(**kwargs)

    @abstractmethod
    async def execute(self, **kwargs) -> Any:
        pass

    def to_param(self) -> Dict:
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters,
            },
        }

class ToolResult(BaseModel):
    output: Any = None
    error: Optional[str] = None

    def __str__(self):
        return f"Error: {self.error}" if self.error else str(self.output)
```

#### æ­¥éª¤ 10ï¼šå®ç°å·¥å…·é›†åˆ

```python
# app/tool/collection.py
from typing import Any, Dict, List
from app.tool.base import BaseTool, ToolResult

class ToolCollection:
    def __init__(self, *tools: BaseTool):
        self.tools = tools
        self.tool_map = {tool.name: tool for tool in tools}

    def to_params(self) -> List[Dict[str, Any]]:
        return [tool.to_param() for tool in self.tools]

    async def execute(self, *, name: str, tool_input: Dict[str, Any] = None) -> ToolResult:
        tool = self.tool_map.get(name)
        if not tool:
            return ToolResult(error=f"Tool {name} not found")

        try:
            result = await tool(**(tool_input or {}))
            return ToolResult(output=result)
        except Exception as e:
            return ToolResult(error=str(e))
```

#### æ­¥éª¤ 11ï¼šå®ç°å…·ä½“å·¥å…·

```python
# app/tool/python_execute.py
import threading
from typing import Dict
from app.tool.base import BaseTool

class PythonExecute(BaseTool):
    name: str = "python_execute"
    description: str = "Execute Python code safely"
    parameters: dict = {
        "type": "object",
        "properties": {
            "code": {
                "type": "string",
                "description": "Python code to execute",
            },
        },
        "required": ["code"],
    }

    async def execute(self, code: str, timeout: int = 5) -> Dict:
        result = {"output": ""}

        def run_code():
            try:
                import sys
                from io import StringIO

                output_buffer = StringIO()
                sys.stdout = output_buffer

                exec(code, {"__builtins__": {}}, {})

                sys.stdout = sys.__stdout__
                result["output"] = output_buffer.getvalue()

            except Exception as e:
                result["output"] = f"Error: {str(e)}"

        thread = threading.Thread(target=run_code)
        thread.start()
        thread.join(timeout)

        if thread.is_alive():
            result["output"] = f"Timeout after {timeout} seconds"

        return result

# app/tool/terminate.py
from app.tool.base import BaseTool

class Terminate(BaseTool):
    name: str = "terminate"
    description: str = "Terminate the current task"
    parameters: dict = {
        "type": "object",
        "properties": {
            "status": {
                "type": "string",
                "description": "Completion status",
            },
        },
        "required": ["status"],
    }

    async def execute(self, status: str = "completed") -> str:
        return f"Task terminated with status: {status}"
```

### ç¬¬äº”é˜¶æ®µï¼šå·¥å…·è°ƒç”¨æ™ºèƒ½ä½“

#### æ­¥éª¤ 12ï¼šå®ç°å·¥å…·è°ƒç”¨æ™ºèƒ½ä½“

```python
# app/agent/toolcall.py
import json
from typing import List
from app.agent.react import ReActAgent
from app.schema import Message, ToolCall, AgentState
from app.tool.collection import ToolCollection
from app.tool.python_execute import PythonExecute
from app.tool.terminate import Terminate
from app.logger import logger

class ToolCallAgent(ReActAgent):
    name: str = "toolcall"
    description: str = "Agent that can use tools"

    available_tools: ToolCollection = ToolCollection(
        PythonExecute(), Terminate()
    )
    tool_calls: List[ToolCall] = []

    async def think(self) -> bool:
        # æ„å»ºæ¶ˆæ¯
        messages = self.memory.messages.copy()

        # è·å–LLMå“åº”
        response = await self.llm.ask_tool(
            messages=messages,
            tools=self.available_tools.to_params(),
            tool_choice="auto"
        )

        # å¤„ç†å·¥å…·è°ƒç”¨
        if response.tool_calls:
            self.tool_calls = [
                ToolCall(
                    id=tc.id,
                    type=tc.type,
                    function=tc.function.dict()
                ) for tc in response.tool_calls
            ]

            # æ·»åŠ åŠ©æ‰‹æ¶ˆæ¯
            assistant_msg = Message(
                role="assistant",
                content=response.content,
                tool_calls=self.tool_calls
            )
            self.memory.add_message(assistant_msg)
            return True
        else:
            # æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œæ·»åŠ æ™®é€šå›å¤
            if response.content:
                assistant_msg = Message.assistant_message(response.content)
                self.memory.add_message(assistant_msg)
            return False

    async def act(self) -> str:
        if not self.tool_calls:
            return "No tools to execute"

        results = []
        for tool_call in self.tool_calls:
            result = await self.execute_tool(tool_call)
            results.append(result)

            # æ·»åŠ å·¥å…·ç»“æœæ¶ˆæ¯
            tool_msg = Message(
                role="tool",
                content=result,
                tool_call_id=tool_call.id,
                name=tool_call.function["name"]
            )
            self.memory.add_message(tool_msg)

            # æ£€æŸ¥æ˜¯å¦æ˜¯ç»ˆæ­¢å·¥å…·
            if tool_call.function["name"] == "terminate":
                self.state = AgentState.FINISHED

        self.tool_calls = []  # æ¸…ç©ºå·¥å…·è°ƒç”¨
        return "\n".join(results)

    async def execute_tool(self, tool_call: ToolCall) -> str:
        try:
            name = tool_call.function["name"]
            args = json.loads(tool_call.function.get("arguments", "{}"))

            result = await self.available_tools.execute(
                name=name,
                tool_input=args
            )

            return str(result)

        except Exception as e:
            logger.error(f"Tool execution failed: {e}")
            return f"Error executing tool: {str(e)}"
```

### ç¬¬å…­é˜¶æ®µï¼šä¸»ç¨‹åºå’Œæµ‹è¯•

#### æ­¥éª¤ 13ï¼šåˆ›å»ºé…ç½®æ–‡ä»¶

```toml
# config/config.toml
[llm]
model = "qwen3-vl-plus-2025-09-23"
base_url = "https://dashscope.aliyuncs.com/compatible-mode/v1"
api_key = "sk-01559a3f857a4b97ab886ff54bea0c24"
max_tokens = 4096
temperature = 0.0
```

#### æ­¥éª¤ 14ï¼šå®ç°ä¸»ç¨‹åº

```python
# main.py
import asyncio
from app.agent.toolcall import ToolCallAgent
from app.logger import logger

async def main():
    """ä¸»ç¨‹åºå…¥å£"""
    # åˆ›å»ºæ™ºèƒ½ä½“
    agent = ToolCallAgent(
        name="MyAgent",
        description="A simple tool-calling agent"
    )

    print("ğŸ¤– MyOpenManus Agent Started!")
    print("Type 'exit' to quit")

    while True:
        try:
            # è·å–ç”¨æˆ·è¾“å…¥
            user_input = input("\nğŸ’¬ You: ")

            if user_input.lower() in ['exit', 'quit', 'bye']:
                print("ğŸ‘‹ Goodbye!")
                break

            if not user_input.strip():
                continue

            # æ‰§è¡Œæ™ºèƒ½ä½“
            logger.info(f"Processing: {user_input}")
            result = await agent.run(user_input)

            print(f"\nğŸ¤– Agent: {result}")

        except KeyboardInterrupt:
            print("\nğŸ‘‹ Goodbye!")
            break
        except Exception as e:
            logger.error(f"Error: {e}")
            print(f"âŒ Error: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

#### æ­¥éª¤ 15ï¼šåˆ›å»ºå®Œæ•´çš„é¡¹ç›®å¯åŠ¨è„šæœ¬

```python
# run.py - å®Œæ•´çš„é¡¹ç›®å¯åŠ¨è„šæœ¬
import asyncio
import sys
from pathlib import Path

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from app.agent.toolcall import ToolCallAgent
from app.tool.python_execute import PythonExecute
from app.tool.terminate import Terminate
from app.tool.collection import ToolCollection
from app.logger import logger

class MyOpenManus:
    """è‡ªå®šä¹‰OpenManuså®ç°"""

    def __init__(self):
        # åˆ›å»ºå·¥å…·é›†åˆ
        tools = ToolCollection(
            PythonExecute(),
            Terminate()
        )

        # åˆ›å»ºæ™ºèƒ½ä½“
        self.agent = ToolCallAgent(
            name="MyOpenManus",
            description="A custom implementation of OpenManus",
            available_tools=tools
        )

    async def chat(self):
        """äº¤äº’å¼èŠå¤©ç•Œé¢"""
        print("ğŸš€ MyOpenManus - è‡ªåˆ¶æ™ºèƒ½ä»£ç†")
        print("=" * 50)
        print("ğŸ’¡ æˆ‘å¯ä»¥å¸®æ‚¨:")
        print("   â€¢ æ‰§è¡ŒPythonä»£ç ")
        print("   â€¢ è§£å†³æ•°å­¦é—®é¢˜")
        print("   â€¢ æ•°æ®åˆ†æ")
        print("   â€¢ ç®—æ³•å®ç°")
        print("=" * 50)
        print("è¾“å…¥ 'exit' é€€å‡ºç¨‹åº\n")

        while True:
            try:
                user_input = input("ğŸ§‘ æ‚¨: ")

                if user_input.lower() in ['exit', 'quit', 'é€€å‡º']:
                    print("ğŸ‘‹ å†è§!")
                    break

                if not user_input.strip():
                    continue

                print("ğŸ¤” æ€è€ƒä¸­...")

                # æ‰§è¡Œæ™ºèƒ½ä½“
                result = await self.agent.run(user_input)

                print(f"\nğŸ¤– åŠ©æ‰‹: ä»»åŠ¡å®Œæˆ!")
                print(f"ğŸ“‹ æ‰§è¡Œç»“æœ:\n{result}\n")

                # é‡ç½®æ™ºèƒ½ä½“çŠ¶æ€
                self.agent.current_step = 0
                self.agent.state = self.agent.state.IDLE

            except KeyboardInterrupt:
                print("\nğŸ‘‹ å†è§!")
                break
            except Exception as e:
                logger.error(f"æ‰§è¡Œé”™è¯¯: {e}")
                print(f"âŒ å‡ºç°é”™è¯¯: {e}\n")

async def main():
    app = MyOpenManus()
    await app.chat()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## ğŸ§ª æµ‹è¯•å’ŒéªŒè¯

### æµ‹è¯•ç”¨ä¾‹é›†åˆ

#### æµ‹è¯• 1ï¼šåŸºç¡€ Python æ‰§è¡Œ

```python
# test_basic.py
import asyncio
from app.agent.toolcall import ToolCallAgent

async def test_python_execution():
    """æµ‹è¯•Pythonä»£ç æ‰§è¡ŒåŠŸèƒ½"""
    agent = ToolCallAgent(name="TestAgent")

    test_cases = [
        "è®¡ç®— 2 + 2",
        "ç”Ÿæˆ1åˆ°10çš„å¹³æ–¹æ•°åˆ—è¡¨",
        "è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰10é¡¹",
        "åˆ›å»ºä¸€ä¸ªç®€å•çš„æ•°æ®å¯è§†åŒ–"
    ]

    for i, test_case in enumerate(test_cases, 1):
        print(f"\nğŸ§ª æµ‹è¯• {i}: {test_case}")
        print("-" * 40)

        result = await agent.run(test_case)
        print(f"âœ… ç»“æœ: {result}")

        # é‡ç½®æ™ºèƒ½ä½“
        agent.current_step = 0
        agent.state = agent.state.IDLE

if __name__ == "__main__":
    asyncio.run(test_python_execution())
```

#### æµ‹è¯• 2ï¼šé”™è¯¯å¤„ç†

```python
# test_error_handling.py
import asyncio
from app.agent.toolcall import ToolCallAgent

async def test_error_handling():
    """æµ‹è¯•é”™è¯¯å¤„ç†æœºåˆ¶"""
    agent = ToolCallAgent(name="ErrorTestAgent")

    error_cases = [
        "æ‰§è¡Œè¿™æ®µæœ‰è¯­æ³•é”™è¯¯çš„ä»£ç : print('hello'",  # è¯­æ³•é”™è¯¯
        "è®¡ç®— 1/0",  # è¿è¡Œæ—¶é”™è¯¯
        "å¯¼å…¥ä¸å­˜åœ¨çš„æ¨¡å—: import nonexistent_module",  # å¯¼å…¥é”™è¯¯
    ]

    for i, case in enumerate(error_cases, 1):
        print(f"\nğŸš¨ é”™è¯¯æµ‹è¯• {i}: {case}")
        print("-" * 50)

        try:
            result = await agent.run(case)
            print(f"ğŸ“‹ å¤„ç†ç»“æœ: {result}")
        except Exception as e:
            print(f"âŒ å¼‚å¸¸: {e}")

        # é‡ç½®æ™ºèƒ½ä½“
        agent.current_step = 0
        agent.state = agent.state.IDLE

if __name__ == "__main__":
    asyncio.run(test_error_handling())
```

#### æµ‹è¯• 3ï¼šå¤æ‚ä»»åŠ¡

```python
# test_complex_tasks.py
import asyncio
from app.agent.toolcall import ToolCallAgent

async def test_complex_tasks():
    """æµ‹è¯•å¤æ‚ä»»åŠ¡å¤„ç†"""
    agent = ToolCallAgent(name="ComplexTestAgent")

    complex_tasks = [
        """
        åˆ›å»ºä¸€ä¸ªå­¦ç”Ÿæˆç»©ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…å«ä»¥ä¸‹åŠŸèƒ½ï¼š
        1. æ·»åŠ å­¦ç”Ÿæˆç»©
        2. è®¡ç®—å¹³å‡åˆ†
        3. æ‰¾å‡ºæœ€é«˜åˆ†å’Œæœ€ä½åˆ†
        4. æ˜¾ç¤ºæˆç»©åˆ†å¸ƒ
        """,

        """
        å®ç°ä¸€ä¸ªç®€å•çš„æ–‡æœ¬åˆ†æå·¥å…·ï¼š
        1. ç»Ÿè®¡å•è¯é¢‘ç‡
        2. æ‰¾å‡ºæœ€å¸¸ç”¨çš„è¯æ±‡
        3. è®¡ç®—æ–‡æœ¬é•¿åº¦ç»Ÿè®¡
        """,

        """
        åˆ›å»ºä¸€ä¸ªæ•°æ®å¯è§†åŒ–ç¤ºä¾‹ï¼š
        1. ç”Ÿæˆéšæœºæ•°æ®
        2. åˆ›å»ºæŸ±çŠ¶å›¾
        3. æ·»åŠ æ ‡é¢˜å’Œæ ‡ç­¾
        """
    ]

    for i, task in enumerate(complex_tasks, 1):
        print(f"\nğŸ¯ å¤æ‚ä»»åŠ¡ {i}:")
        print("=" * 60)
        print(task.strip())
        print("=" * 60)

        result = await agent.run(task)
        print(f"\nâœ… å®Œæˆç»“æœ:\n{result}")

        # é‡ç½®æ™ºèƒ½ä½“
        agent.current_step = 0
        agent.state = agent.state.IDLE

        input("\næŒ‰å›è½¦é”®ç»§ç»­ä¸‹ä¸€ä¸ªæµ‹è¯•...")

if __name__ == "__main__":
    asyncio.run(test_complex_tasks())
```

### æ€§èƒ½æµ‹è¯•

```python
# test_performance.py
import asyncio
import time
from app.agent.toolcall import ToolCallAgent

async def test_performance():
    """æ€§èƒ½æµ‹è¯•"""
    agent = ToolCallAgent(name="PerfTestAgent")

    tasks = [
        "è®¡ç®—1åˆ°1000çš„å’Œ",
        "ç”Ÿæˆ100ä¸ªéšæœºæ•°å¹¶æ’åº",
        "è®¡ç®—åœ†å‘¨ç‡åˆ°å°æ•°ç‚¹å10ä½",
        "åˆ›å»ºä¸€ä¸ª10x10çš„çŸ©é˜µå¹¶è®¡ç®—è¡Œåˆ—å¼"
    ]

    print("ğŸš€ æ€§èƒ½æµ‹è¯•å¼€å§‹")
    print("=" * 50)

    total_time = 0

    for i, task in enumerate(tasks, 1):
        print(f"\nâ±ï¸  æµ‹è¯• {i}: {task}")

        start_time = time.time()
        result = await agent.run(task)
        end_time = time.time()

        execution_time = end_time - start_time
        total_time += execution_time

        print(f"â° æ‰§è¡Œæ—¶é—´: {execution_time:.2f}ç§’")
        print(f"ğŸ“Š ç»“æœé•¿åº¦: {len(str(result))} å­—ç¬¦")

        # é‡ç½®æ™ºèƒ½ä½“
        agent.current_step = 0
        agent.state = agent.state.IDLE

    print(f"\nğŸ“ˆ æ€»æ‰§è¡Œæ—¶é—´: {total_time:.2f}ç§’")
    print(f"ğŸ“Š å¹³å‡æ‰§è¡Œæ—¶é—´: {total_time/len(tasks):.2f}ç§’")

if __name__ == "__main__":
    asyncio.run(test_performance())
```

---

## â“ å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 1. é…ç½®ç›¸å…³é—®é¢˜

#### Q: é…ç½®æ–‡ä»¶æ‰¾ä¸åˆ°

```
FileNotFoundError: No configuration file found in config directory
```

**è§£å†³æ–¹æ¡ˆï¼š**

```bash
# ç¡®ä¿é…ç½®æ–‡ä»¶å­˜åœ¨
mkdir -p config
cp config/config.example.toml config/config.toml
# ç¼–è¾‘é…ç½®æ–‡ä»¶ï¼Œæ·»åŠ æ­£ç¡®çš„APIå¯†é’¥
```

#### Q: API å¯†é’¥æ— æ•ˆ

```
AuthenticationError: Invalid API key
```

**è§£å†³æ–¹æ¡ˆï¼š**

1. æ£€æŸ¥ API å¯†é’¥æ ¼å¼æ˜¯å¦æ­£ç¡®
2. ç¡®è®¤ API å¯†é’¥æœ‰æ•ˆæœŸ
3. éªŒè¯ base_url æ˜¯å¦æ­£ç¡®

```toml
[llm]
model = "qwen3-vl-plus-2025-09-23"
base_url = "https://dashscope.aliyuncs.com/compatible-mode/v1"
api_key = "sk-your-actual-api-key-here"  # æ›¿æ¢ä¸ºçœŸå®å¯†é’¥
```

### 2. ä¾èµ–å®‰è£…é—®é¢˜

#### Q: Pydantic ç‰ˆæœ¬å†²çª

```
ImportError: cannot import name 'BaseModel' from 'pydantic'
```

**è§£å†³æ–¹æ¡ˆï¼š**

```bash
# å¸è½½æ—§ç‰ˆæœ¬
pip uninstall pydantic pydantic-core

# å®‰è£…æŒ‡å®šç‰ˆæœ¬
pip install pydantic==2.10.4 pydantic-core==2.27.2
```

#### Q: OpenAI å®¢æˆ·ç«¯ç‰ˆæœ¬é—®é¢˜

```
AttributeError: 'AsyncOpenAI' object has no attribute 'chat'
```

**è§£å†³æ–¹æ¡ˆï¼š**

```bash
# æ›´æ–°åˆ°æ­£ç¡®ç‰ˆæœ¬
pip install openai==1.58.1
```

### 3. è¿è¡Œæ—¶é”™è¯¯

#### Q: å¼‚æ­¥å‡½æ•°è°ƒç”¨é”™è¯¯

```
RuntimeError: asyncio.run() cannot be called from a running event loop
```

**è§£å†³æ–¹æ¡ˆï¼š**

```python
# é”™è¯¯çš„è°ƒç”¨æ–¹å¼
asyncio.run(agent.run("test"))

# æ­£ç¡®çš„è°ƒç”¨æ–¹å¼
await agent.run("test")

# æˆ–è€…åœ¨ä¸»å‡½æ•°ä¸­
if __name__ == "__main__":
    asyncio.run(main())
```

#### Q: å·¥å…·æ‰§è¡Œè¶…æ—¶

```
Execution timeout after 5 seconds
```

**è§£å†³æ–¹æ¡ˆï¼š**

```python
# å¢åŠ è¶…æ—¶æ—¶é—´
class PythonExecute(BaseTool):
    async def execute(self, code: str, timeout: int = 30):  # å¢åŠ åˆ°30ç§’
        # ... æ‰§è¡Œä»£ç 
```

### 4. å†…å­˜å’Œæ€§èƒ½é—®é¢˜

#### Q: å†…å­˜ä½¿ç”¨è¿‡å¤š

```
MemoryError: Unable to allocate memory
```

**è§£å†³æ–¹æ¡ˆï¼š**

```python
# é™åˆ¶å†…å­˜ä¸­çš„æ¶ˆæ¯æ•°é‡
class Memory(BaseModel):
    max_messages: int = Field(default=50)  # å‡å°‘åˆ°50æ¡

    def add_message(self, message: Message) -> None:
        self.messages.append(message)
        # è‡ªåŠ¨æ¸…ç†æ—§æ¶ˆæ¯
        if len(self.messages) > self.max_messages:
            self.messages = self.messages[-self.max_messages:]
```

#### Q: API è°ƒç”¨é¢‘ç‡é™åˆ¶

```
RateLimitError: Rate limit exceeded
```

**è§£å†³æ–¹æ¡ˆï¼š**

```python
# å¢åŠ é‡è¯•ç­‰å¾…æ—¶é—´
@retry(
    wait=wait_random_exponential(min=2, max=120),  # å¢åŠ ç­‰å¾…æ—¶é—´
    stop=stop_after_attempt(10),  # å¢åŠ é‡è¯•æ¬¡æ•°
)
async def ask_tool(self, **kwargs):
    # ... APIè°ƒç”¨
```

### 5. è°ƒè¯•æŠ€å·§

#### å¯ç”¨è¯¦ç»†æ—¥å¿—

```python
# app/logger.py
def setup_logger(print_level="DEBUG", logfile_level="DEBUG"):  # æ”¹ä¸ºDEBUG
    # ... æ—¥å¿—é…ç½®
```

#### æ·»åŠ è°ƒè¯•ä¿¡æ¯

```python
# åœ¨å…³é”®ä½ç½®æ·»åŠ æ—¥å¿—
logger.debug(f"Tool input: {tool_input}")
logger.debug(f"Tool result: {result}")
logger.debug(f"Agent state: {self.state}")
```

#### ä½¿ç”¨ Python è°ƒè¯•å™¨

```python
import pdb

async def execute_tool(self, tool_call):
    pdb.set_trace()  # è®¾ç½®æ–­ç‚¹
    # ... å·¥å…·æ‰§è¡Œä»£ç 
```

---

## ğŸ“ è¿›é˜¶å­¦ä¹ è·¯å¾„

### é˜¶æ®µä¸€ï¼šæŒæ¡åŸºç¡€ (1-2 å‘¨)

**å­¦ä¹ ç›®æ ‡ï¼š**

- ç†è§£é¡¹ç›®åŸºæœ¬æ¶æ„
- èƒ½å¤Ÿè¿è¡Œå’Œä¿®æ”¹ç°æœ‰ä»£ç 
- æŒæ¡åŸºç¡€çš„å¼‚æ­¥ç¼–ç¨‹

**å®è·µé¡¹ç›®ï¼š**

1. **ç®€åŒ–ç‰ˆæ™ºèƒ½ä½“**

   ```python
   # åˆ›å»ºä¸€ä¸ªåªæœ‰åŸºç¡€å¯¹è¯åŠŸèƒ½çš„æ™ºèƒ½ä½“
   class SimpleAgent(BaseAgent):
       async def step(self) -> str:
           # å®ç°ç®€å•çš„å¯¹è¯é€»è¾‘
           pass
   ```

2. **è‡ªå®šä¹‰å·¥å…·**
   ```python
   # åˆ›å»ºä¸€ä¸ªè®¡ç®—å™¨å·¥å…·
   class Calculator(BaseTool):
       async def execute(self, expression: str) -> float:
           # å®‰å…¨åœ°è®¡ç®—æ•°å­¦è¡¨è¾¾å¼
           pass
   ```

### é˜¶æ®µäºŒï¼šæ‰©å±•åŠŸèƒ½ (2-3 å‘¨)

**å­¦ä¹ ç›®æ ‡ï¼š**

- æ·»åŠ æ–°çš„å·¥å…·ç±»å‹
- å®ç°æ›´å¤æ‚çš„æ™ºèƒ½ä½“é€»è¾‘
- ä¼˜åŒ–æ€§èƒ½å’Œé”™è¯¯å¤„ç†

**å®è·µé¡¹ç›®ï¼š**

1. **æ–‡ä»¶æ“ä½œå·¥å…·**

   ```python
   class FileManager(BaseTool):
       async def execute(self, action: str, filename: str, content: str = None):
           # å®ç°æ–‡ä»¶è¯»å†™åŠŸèƒ½
           pass
   ```

2. **ç½‘ç»œè¯·æ±‚å·¥å…·**

   ```python
   class WebRequester(BaseTool):
       async def execute(self, url: str, method: str = "GET"):
           # å®ç°HTTPè¯·æ±‚åŠŸèƒ½
           pass
   ```

3. **æ•°æ®åˆ†ææ™ºèƒ½ä½“**
   ```python
   class DataAnalyst(ToolCallAgent):
       # ä¸“é—¨ç”¨äºæ•°æ®åˆ†æä»»åŠ¡çš„æ™ºèƒ½ä½“
       pass
   ```

### é˜¶æ®µä¸‰ï¼šé«˜çº§ç‰¹æ€§ (3-4 å‘¨)

**å­¦ä¹ ç›®æ ‡ï¼š**

- å®ç°å¤šæ™ºèƒ½ä½“åä½œ
- æ·»åŠ æŒä¹…åŒ–å­˜å‚¨
- é›†æˆå¤–éƒ¨æœåŠ¡

**å®è·µé¡¹ç›®ï¼š**

1. **å¤šæ™ºèƒ½ä½“ç³»ç»Ÿ**

   ```python
   class MultiAgentSystem:
       def __init__(self):
           self.agents = {
               "coder": CodingAgent(),
               "analyst": DataAnalyst(),
               "researcher": ResearchAgent()
           }

       async def delegate_task(self, task: str) -> str:
           # æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©åˆé€‚çš„æ™ºèƒ½ä½“
           pass
   ```

2. **æŒä¹…åŒ–å­˜å‚¨**

   ```python
   class PersistentMemory(Memory):
       async def save_to_db(self):
           # ä¿å­˜å¯¹è¯å†å²åˆ°æ•°æ®åº“
           pass

       async def load_from_db(self, session_id: str):
           # ä»æ•°æ®åº“åŠ è½½å¯¹è¯å†å²
           pass
   ```

3. **Web ç•Œé¢**

   ```python
   # ä½¿ç”¨FastAPIåˆ›å»ºWebç•Œé¢
   from fastapi import FastAPI

   app = FastAPI()

   @app.post("/chat")
   async def chat_endpoint(message: str):
       # å¤„ç†Webè¯·æ±‚
       pass
   ```

### é˜¶æ®µå››ï¼šç”Ÿäº§éƒ¨ç½² (4-5 å‘¨)

**å­¦ä¹ ç›®æ ‡ï¼š**

- å®¹å™¨åŒ–éƒ¨ç½²
- ç›‘æ§å’Œæ—¥å¿—
- å®‰å…¨æ€§å’Œæ€§èƒ½ä¼˜åŒ–

**å®è·µé¡¹ç›®ï¼š**

1. **Docker å®¹å™¨åŒ–**

   ```dockerfile
   # Dockerfile
   FROM python:3.12-slim

   WORKDIR /app
   COPY requirements.txt .
   RUN pip install -r requirements.txt

   COPY . .
   CMD ["python", "main.py"]
   ```

2. **ç›‘æ§ç³»ç»Ÿ**

   ```python
   # æ·»åŠ æ€§èƒ½ç›‘æ§
   import time
   from functools import wraps

   def monitor_performance(func):
       @wraps(func)
       async def wrapper(*args, **kwargs):
           start_time = time.time()
           result = await func(*args, **kwargs)
           end_time = time.time()

           logger.info(f"{func.__name__} took {end_time - start_time:.2f}s")
           return result
       return wrapper
   ```

3. **å®‰å…¨å¢å¼º**

   ```python
   # ä»£ç æ‰§è¡Œå®‰å…¨é™åˆ¶
   import resource

   def limit_resources():
       # é™åˆ¶å†…å­˜ä½¿ç”¨
       resource.setrlimit(resource.RLIMIT_AS, (128*1024*1024, 128*1024*1024))
       # é™åˆ¶CPUæ—¶é—´
       resource.setrlimit(resource.RLIMIT_CPU, (5, 5))
   ```

---

## ğŸ“š æ¨èå­¦ä¹ èµ„æº

### å®˜æ–¹æ–‡æ¡£

- [Pydantic Documentation](https://docs.pydantic.dev/)
- [OpenAI API Documentation](https://platform.openai.com/docs)
- [Python Asyncio Documentation](https://docs.python.org/3/library/asyncio.html)

### è¿›é˜¶ä¹¦ç±

- ã€ŠEffective Pythonã€‹- Brett Slatkin
- ã€ŠArchitecture Patterns with Pythonã€‹- Harry Percival
- ã€ŠPython Tricksã€‹- Dan Bader

### å®è·µé¡¹ç›®å»ºè®®

1. **ä¸ªäººåŠ©æ‰‹æœºå™¨äºº** - é›†æˆæ—¥å†ã€é‚®ä»¶ã€ä»»åŠ¡ç®¡ç†
2. **ä»£ç å®¡æŸ¥åŠ©æ‰‹** - è‡ªåŠ¨åˆ†æä»£ç è´¨é‡å’Œå»ºè®®
3. **æ•°æ®åˆ†æå¹³å°** - è‡ªåŠ¨åŒ–æ•°æ®å¤„ç†å’Œå¯è§†åŒ–
4. **å­¦ä¹ ä¼™ä¼´ç³»ç»Ÿ** - ä¸ªæ€§åŒ–å­¦ä¹ è·¯å¾„æ¨è

---

## ğŸ¯ æ€»ç»“

é€šè¿‡æœ¬å­¦ä¹ æŒ‡å—ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

1. **ç†è§£ç°ä»£ Python å¼€å‘æ¨¡å¼**

   - å¼‚æ­¥ç¼–ç¨‹
   - ç±»å‹æ³¨è§£
   - è®¾è®¡æ¨¡å¼åº”ç”¨

2. **æŒæ¡ AI æ™ºèƒ½ä½“å¼€å‘**

   - æ™ºèƒ½ä½“æ¶æ„è®¾è®¡
   - å·¥å…·ç³»ç»Ÿé›†æˆ
   - LLM API è°ƒç”¨

3. **å…·å¤‡é¡¹ç›®å®æˆ˜èƒ½åŠ›**

   - å®Œæ•´é¡¹ç›®ç»“æ„
   - é”™è¯¯å¤„ç†æœºåˆ¶
   - æ€§èƒ½ä¼˜åŒ–æŠ€å·§

4. **å»ºç«‹æ‰©å±•æ€ç»´**
   - æ¨¡å—åŒ–è®¾è®¡
   - å¯æ‰©å±•æ¶æ„
   - æœ€ä½³å®è·µåº”ç”¨

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨ï¼š**

1. æŒ‰ç…§æ­¥éª¤æ­å»ºåŸºç¡€æ¡†æ¶
2. é€æ­¥å®ç°å„ä¸ªæ¨¡å—
3. è¿›è¡Œå……åˆ†çš„æµ‹è¯•
4. æ ¹æ®éœ€æ±‚æ‰©å±•åŠŸèƒ½
5. æŒç»­å­¦ä¹ å’Œä¼˜åŒ–

ç¥æ‚¨å­¦ä¹ æ„‰å¿«ï¼Œæ—©æ—¥æˆä¸º Python å’Œ AI å¼€å‘çš„ä¸“å®¶ï¼ğŸš€

---

_æœ¬å­¦ä¹ æŒ‡å—åŸºäº OpenManus é¡¹ç›®æ·±åº¦åˆ†æç¼–å†™ï¼Œé€‚åˆ Python åˆå­¦è€…åˆ°è¿›é˜¶å¼€å‘è€…ä½¿ç”¨ã€‚å¦‚æœ‰é—®é¢˜ï¼Œæ¬¢è¿äº¤æµè®¨è®ºï¼_

```

```
